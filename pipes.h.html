<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>pipes.h &mdash; 3</title>
<style type="text/css">
.roman {
	font-family: serif;
}
.helvetica {
	font-family: sans-serif;
}
h3 em,
h3 .roman,
h4 em,
h4 .roman {
	font-weight: normal;
}
</style>
</head>
<body>
<h1>pipes.h</h1>
<h2>NAME</h2>
pipes.h &mdash; build pipe chains
<br/>
<h2>SYNOPSIS</h2>

<pre>
<strong>#include &lt;pipes/pipes.h&gt;</strong>
<br/>
</pre><h3>Data Structures</h3>
<pre>
struct <strong>pipes</strong>;
struct <strong>pipes_chain</strong>;
<br/>
</pre><h3>Functions</h3>
<pre>
int <strong>pipes_open</strong>(char const *const <em>argv</em>[], char const *const <em>envp</em>[],
               struct <strong>pipes</strong>* <em>pipes</em>);
int <strong>pipes_close</strong>(struct <strong>pipes</strong>* <em>pipes</em>);
<br/>
int <strong>pipes_open_chain</strong>(struct <strong>pipes_chain</strong> <em>chain</em>[]);
int <strong>pipes_close_chain</strong>(struct <strong>pipes_chain</strong> <em>chain</em>[]);
int <strong>pipes_kill_chain</strong>(struct <strong>pipes_chain</strong> <em>chain</em>[], int <em>sig</em>);
<br/>
int <strong>pipes_take_in</strong>(struct <strong>pipes_chain</strong> <em>chain</em>[]);
int <strong>pipes_take_out</strong>(struct <strong>pipes_chain</strong> <em>chain</em>[]);
int <strong>pipes_take_err</strong>(struct <strong>pipes_chain</strong> <em>chain</em>[]);
<br/>
</pre><h3>Macros</h3>
<pre>
#define <strong>PIPES_GET_LAST</strong>(<em>CHAIN</em>)
#define <strong>PIPES_GET_IN</strong>(<em>CHAIN</em>)
#define <strong>PIPES_GET_OUT</strong>(<em>CHAIN</em>)
#define <strong>PIPES_GET_ERR</strong>(<em>CHAIN</em>)
<br/>
</pre><h2>DESCRIPTION</h2>
Functions to build pipe chains between programs.
<br/>
<h3>sctruct pipes</h3>
<br/>
<br/>
<pre>
struct pipes {
	pid_t pid;     /* process ID of opened child process */
	int   infd;    /* pipe to stdin of child process     */
	int   outfd;   /* pipe to stdout of child process    */
	int   errfd;   /* pipe to stderr of child process    */
};
</pre>
<br/>
The <em>infd</em>, <em>outfd</em>, and <em>errfd</em> fields of <em>pipes</em> may either be set to valid
file descriptors or to one of the following special values. In case they are file descriptors
they will be used as the appropriate stream in the child process and will be closed in the
parent process. <strong>pipes_open</strong>() and <strong>pipes_open_chain</strong>() ensure that any passed file
descriptor will be always closed, no matter if the call was successful or resulted in an error.
<br/>

<h4>PIPES_LEAVE</h4>
Leave stream unchaned (i.e. don&#x27;t open a pipe to the stream of the child process).
<br/>

<h4>PIPES_PIPE</h4>
Open a pipe to this stream of the child process. For <em>infd</em> the write end of the pipe will
be returned in the same field. For <em>outfd</em> and <em>errfd</em> the read end of the pipe will
be retuned in the same field.
<br/>

<h4>PIPES_NULL</h4>
Pipe this stream to/from <em>/dev/null</em>.
<br/>

<h4>PIPES_TO_STDOUT</h4>
Redirect child process stream to stdout. This is only valid for the <em>outfd</em> and <em>errfd</em>
fields. For <em>outfd</em> it is equivalent to <em>PIPES_PIPE</em>.
<br/>

<h4>PIPES_TO_STDERR</h4>
Redirect child process stream to stdout. This is only valid for the <em>outfd</em> and <em>errfd</em>
fields. For <em>errfd</em> it is equivalent to <em>PIPES_PIPE</em>.
<br/>

<h4>PIPES_TEMP</h4>
Open a temporary file as this stream. If supported by the kernel and filesystem this
will be done using the <strong>O_TMPFILE</strong> flag. A copy of the file descriptor will be
returned in the same field.
<br/>
<br/>
These helper macros can be used to initialize the <em>pipes</em> structure:
<br/>

<h4>PIPES_PASS</h4>
Set <em>infd</em> and <em>outfd</em> to <strong>PIPES_PIPE</strong> and set <em>errfd</em> to <strong>PIPES_LEAVE</strong>.
This is useful for intermediaries in a pipe chain.
<br/>

<h4>PIPES_IN(<em>IN</em>)</h4>
Set <em>infd</em> to <em>IN</em>, <em>outfd</em> to <strong>PIPES_PIPE</strong> and <em>errfd</em> to
<strong>PIPES_LEAVE</strong>.
<br/>

<h4>PIPES_OUT(<em>OUT</em>)</h4>
Set <em>infd</em> to <strong>PIPES_PIPE</strong>, <em>outfd</em> to <em>OUT</em> and <em>errfd</em> to
<strong>PIPES_LEAVE</strong>.
<br/>

<h4>PIPES_ERR(<em>ERR</em>)</h4>
Set <em>infd</em> to <strong>PIPES_PIPE</strong>, <em>outfd</em> to <strong>PIPES_LEAVE</strong> and <em>errfd</em> to
<em>ERR</em>.
<br/>

<h4>PIPES_FIRST</h4>
Set <em>outfd</em> to <strong>PIPES_PIPE</strong> and the rest to <strong>PIPES_LEAVE</strong>. This is useful for
the first command in a chain.
<br/>

<h4>PIPES_LAST</h4>
Set <em>infd</em> to <strong>PIPES_PIPE</strong> and the rest to <strong>PIPES_LEAVE</strong>. This is useful for the
last command in a chain.
<br/>
<h3>struct pipes_chain</h3>
<br/>
<br/>
<pre>
struct pipes_chain {
	struct pipes       pipes;   /* see above                         */
	char const* const* argv;    /* NULL terminated argument array    */
	char const* const* envp;    /* NULL terminated environment array */
};
</pre>
<br/>
<strong>pipes_chain_open</strong>() accepts an array of <strong>pipe_chain</strong> structures. It passed the fields
of each structure to an <strong>pipes_open</strong>() call.
<br/>
<h3>int pipes_open(char const *const <em>argv</em>[], char const *const <em>envp</em>[], struct pipes* <em>pipes</em>);</h3>
Spawn a child process and open pipes to it&#x27;s io streams.
<br/>
<em>argv</em> is a NULL terminated array of arguments. The first argument is the program to execute
and does not need to be an absolute path.
<br/>
<em>envp</em> is a NULL terminated array of environment variables. After forking, the child
processes global <strong>environ</strong> variable will be set to this value. If <em>envp</em> is NULL it will
be ignored. See also: <a href="https://linux.die.net/man/3/environ"><strong>environ</strong>(3)</a>
<br/>
On success returns 0, on error returns -1 and sets <strong>errno</strong>. If <em>infd</em>, <em>outfd</em> or
<em>errfd</em> has an illegal value <strong>errno</strong> is set to <strong>EINVAL</strong>. For other possible error
codes see <a href="https://linux.die.net/man/2/open"><strong>open</strong>(2),</a> <a href="https://linux.die.net/man/2/pipe2"><strong>pipe2</strong>(2),</a> <a href="https://linux.die.net/man/2/dup2"><strong>dup2</strong>(2),</a> and <a href="https://linux.die.net/man/2/fork"><strong>fork</strong>(2).</a>
<br/>
<h3>int pipes_close(struct pipes* <em>pipes</em>)</h3>
Close all pipes previously opened with <strong>pipes_open</strong>(). It is save to call this even if the
<strong>pipes_open</strong>() call failed.
<br/>
Returns 0 on success, -1 if <a href="https://linux.die.net/man/2/close"><strong>close</strong>(2)</a> on any of the file descriptors failed.
<br/>
<h3>int pipes_open_chain(struct pipes_chain <em>chain</em>[])</h3>
Spawn a number of child prcesses and open pipes between them. Intermediate pipes are
not accessible by the calling process.
<br/>
The last element of <em>chain</em> is marked by setting <em>argv</em> to NULL. <em>envp</em> can be NULL
and <em>pipes</em> must be initialized in the same way as for <strong>pipes_open</strong>().
<br/>
On success returns 0, on error returns -1 and sets <strong>errno</strong>. In addition to the errors
defined by <strong>open_pipes</strong>() <strong>errno</strong> will be set to <strong>EINVAL</strong> if <em>chain</em> is NULL
or points to an empty array or if an element in the chain has <em>infd</em> defined as
<strong>PIPES_PIPE</strong> but the preceding element hasn&#x27;t defined <em>outfd</em> as <strong>PIPES_PIPE</strong>.
<br/>
<h3>int pipes_close_chain(struct pipes_chain <em>chain</em>[])</h3>
Close all pipes in <em>chain</em> and sets them to -1. It is save to call this even if the
<strong>pipes_open_chain</strong>() call failed.
<br/>
Returns 0 on success, -1 if <a href="https://linux.die.net/man/2/close"><strong>close</strong>(2)</a> on any of the file descriptors failed.
<br/>
<h3>int pipes_kill_chain(struct pipes_chain <em>chain</em>[], int <em>sig</em>)</h3>
Send signal <em>sig</em> to all processes in <em>chain</em>.
<br/>
Returns 0 on success, -1 if <a href="https://linux.die.net/man/2/kill"><strong>kill</strong>(2)</a> on any of the processes failed. It will still try
to send the signal to the rest of the chain.
<br/>
<h3>int pipes_take_in(struct pipes_chain <em>chain</em>[])</h3>
Return the pipe to the input stream pipe of the first process in the <em>chain</em>. The <em>infd</em>
field in the chain will be set to -1 so a successive <strong>pipes_close_chain</strong>() call won&#x27;t close
it.
<br/>
If the chain is empty -1 will be returned and <strong>errno</strong> will be set to <strong>EINVAL</strong>. Note that
-1 will also be returned if <em>infd</em> of the first element is -1.
<br/>
<h3>int pipes_take_out(struct pipes_chain <em>chain</em>[])</h3>
Return the pipe to the output stream pipe of the last process in the <em>chain</em>. The <em>outfd</em>
field in the chain will be set to -1 so a successive <strong>pipes_close_chain</strong>() call won&#x27;t close it.
<br/>
If the chain is empty -1 will be returned and <strong>errno</strong> will be set to <strong>EINVAL</strong>. Note that
-1 will also be returned if <em>outfd</em> of the last element is -1.
<br/>
<h3>int pipes_take_err(struct pipes_chain <em>chain</em>[])</h3>
Return the pipe to the error stream pipe of the last process in the <em>chain</em>. The <em>errfd</em>
field in the chain will be set to -1 so a successive <strong>pipes_close_chain</strong>() call won&#x27;t close it.
<br/>
If the chain is empty -1 will be returned and <strong>errno</strong> will be set to <strong>EINVAL</strong>. Note that
-1 will also be returned if <em>errfd</em> of the last element is -1.
<br/>
<h3>PIPES_GET_LAST(<em>CHAIN</em>)</h3>
Macro to get the last pipe in <em>CHAIN</em>. Note that <em>CHAIN</em> must be an array, not a pointer.
<br/>
<h3>PIPES_GET_IN(<em>CHAIN</em>)</h3>
Macro to get the input stream pipe of the first process in <em>CHAIN</em>.
<br/>
<h3>PIPES_GET_OUT(<em>CHAIN</em>)</h3>
Macro to get the output stream pipe of the last process in <em>CHAIN</em>. Note that <em>CHAIN</em>
must be an array, not a pointer.
<br/>
<h3>PIPES_GET_ERR(<em>CHAIN</em>)</h3>
Macro to get the error stream pipe of the last process in <em>CHAIN</em>. Note that <em>CHAIN</em>
must be an array, not a pointer.
<br/>
<h2>SOURCE</h2>
Get the source at <a href="https://github.com/panzi/pipes">https://github.com/panzi/pipes</a>
<br/>
<h2>AUTHOR</h2>
Mathias Panzenböck (grosser.meister.morti@gmx.net)
<br/>
<h2>SEE ALSO</h2>

<a href="https://linux.die.net/man/3/environ"><strong>environ</strong><span class="roman">(3),</span></a>
<a href="https://linux.die.net/man/3/execvp"><strong>execvp</strong><span class="roman">(3),</span></a>
<a href="https://linux.die.net/man/2/fork"><strong>fork</strong><span class="roman">(2),</span></a>
<a href="https://linux.die.net/man/2/pipe2"><strong>pipe2</strong><span class="roman">(2),</span></a>
<a href="https://linux.die.net/man/3/popen"><strong>popen</strong><span class="roman">(3)</span></a>

</body>
</html>
